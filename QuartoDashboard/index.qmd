---
title: "2023_DAIE_ICA_2_RB"
format: dashboard
server: shiny
theme:
  - custom.scss
---

```{r}
#| context: server-start

# See https://quarto.org/docs/interactive/shiny/execution.html#context-server-start

# In here we could add code (e.g., obtain a connection to a DB, read a CSV, download a ZIP from a remote source) that is run once and shared across multiple open sessions (i.e. multiple browser views of these pages that the user may open in Chrome/Edge)

```

```{r}
#| context: setup
library(RSQLite)
library(vistime)
library(plotly)

con <- dbConnect(drv=RSQLite::SQLite(), dbname="ICA_2023.sqlite")


projects <- dbGetQuery(con,'SELECT * FROM Projects;')
```

# Data View

```{r}
#| title: customers

# Create a table with the DT package 
datatable(head(customers))

```

```{r}
#| title: projects

datatable(head(projects))

```

```{r}
#| title: developers

datatable(head(developers))

```

```{r}
#| title: assets

datatable(head(assets))

```

# Project Timelines

<!--
Plot 1: 
Project timelines
Field 1: Start date
Field 2: End date
-->

```{r Date range inputs for project timelines plot}
#| content: card-sidebar

# These dateRangeInputs control the 
dateRangeInput(
  'projectStartRange',
  'Project start date range',
  start = min(projects$StartDate),
  end = max(projects$StartDate),
  min = min(projects$StartDate),
  max = max(projects$StartDate),
  format = "yyyy-mm-dd",
  startview = "month",
  weekstart = 0,
  language = "en",
  separator = " to "
)

dateRangeInput(
  'projectEndRange',
  'Project end date range',
  start = min(projects$EndDate),
  end = max(projects$EndDate),
  min = min(projects$EndDate),
  max = max(projects$EndDate),
  format = "yyyy-mm-dd",
  startview = "month",
  weekstart = 0,
  language = "en",
  separator = " to "
)

```

```{r Plot project timelines}
#| title: Project timelines

plotlyOutput("projectTimelines")
```

# Geographic spend

```{r Total project spend mapped by customer city}
#| title: Total project budget by city

# Based on https://www.r-bloggers.com/2017/08/tidyverse-practice-mapping-large-european-cities/
map.europe <- map_data("world")
df.euro_cities <- city_coords

# Need to use fuzzy join because Rome is called Roma in the city_coords dataset
d <- fuzzy_left_join(customerCityBudgets, df.euro_cities,
                      by = c("City" = "city"),
                      match_fun = list(function(x,y) stringdist(tolower(x),tolower(y)) < 2)
                      )

theme.maptheeme <-
  theme(text = element_text(family = "Gill Sans", color = "#444444")) +
  theme(plot.title = element_text(size = 32)) +
  theme(plot.subtitle = element_text(size = 16)) +
  theme(panel.grid = element_blank()) +
  theme(axis.text = element_blank()) +
  theme(axis.ticks = element_blank()) +
  theme(axis.title = element_blank()) +
  theme(legend.background = element_blank()) +
  theme(legend.key = element_blank()) +
  theme(legend.title = element_text(size = 18)) +
  theme(legend.text = element_text(size = 10)) +
  theme(panel.background = element_rect(fill = "#596673")) +
  theme(panel.grid = element_blank())

p <- ggplot() +
  geom_polygon(
    data = map.europe,
    aes(x = long, y = lat, group = group),
    fill = "#DEDEDE",
    colour = "#818181",
    size = .15
  ) +
  geom_point(data = d, aes(x = lon, y = lat, size = Budget, name = City), color = "red", alpha = .3) +
  coord_cartesian(xlim = c(-9,45), ylim = c(32,70)) +
  scale_size_continuous(range = c(.7,15), breaks = c(1100000, 4000000, 8000000, 12000000), name = "Population", labels = scales::comma_format()) +
  theme.maptheeme


ggplotly(p)

#p <- ggplot() +
  #geom_polygon(data = map.europe, aes(x = long, y = lat, group = group)) +
  #geom_point(data = d, aes(x = lon, y = lat, size = Budget, name = City), color = "red", alpha = .9) +
  #coord_cartesian(xlim = c(-9,45), ylim = c(32,70))

#style(ggplotly(p),visible="True", traces = 0)
```



```{r}
#| context: server

##################################################
# Timeline view
##################################################
timelineFilteredProjects <- reactive({
  projects %>%
    filter(StartDate >= input$projectStartRange[1]) %>%
    filter(StartDate <= input$projectStartRange[2]) %>%
    filter(EndDate >= input$projectEndRange[1]) %>%
    filter(EndDate <= input$projectEndRange[2])
})


timelineData <- reactive({
  data.frame(event = timelineFilteredProjects()$ProjectName,
             start = as.Date(timelineFilteredProjects()$StartDate), 
             end   = as.Date(timelineFilteredProjects()$EndDate),
             group = "Projects")
})

output$projectTimelines <- renderPlotly({
  vistime(
    timelineData(),
    optimize_y = FALSE
    )
})

##################################################
# Budget view
##################################################
```
