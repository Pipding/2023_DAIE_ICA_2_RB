---
title: "2023_DAIE_ICA_2_RB"
format: dashboard
server: shiny
theme:
  - custom.scss
---

```{r}
#| context: server-start

# See https://quarto.org/docs/interactive/shiny/execution.html#context-server-start

# In here we could add code (e.g., obtain a connection to a DB, read a CSV, download a ZIP from a remote source) that is run once and shared across multiple open sessions (i.e. multiple browser views of these pages that the user may open in Chrome/Edge)

```

```{r}
#| context: setup
library(RSQLite)
library(vistime)
library(plotly)
library(europop)
library(fuzzyjoin)
library(stringdist)

con <- dbConnect(drv=RSQLite::SQLite(), dbname="ICA_2023.sqlite")


projects <- dbGetQuery(con,'SELECT * FROM Projects;')

customerCityBudgets <- dbGetQuery(con, '
SELECT
  CustomerName,
  CustomerCity AS City,
  CustomerCountry AS Country,
  Budget
FROM Customers Join Projects P on Customers.CustomerID = P.CustomerID')

map.europe <- map_data("world")
df.euro_cities <- city_coords

# Need to use fuzzy join because Rome is called Roma in the city_coords dataset
df.geo_budget <- fuzzy_left_join(
  customerCityBudgets,
  df.euro_cities,
  by = c("City" = "city"),
  match_fun = list(function(x,y) stringdist(tolower(x),tolower(y)) < 2)
  )

df.geo_budget <- subset(df.geo_budget, select = -c(city) )
```

# Data View

```{r}
#| title: customers

# Create a table with the DT package 
datatable(head(customers))

```

```{r}
#| title: projects

datatable(head(projects))

```

```{r}
#| title: developers

datatable(head(developers))

```

```{r}
#| title: assets

datatable(head(assets))

```

# Project Timelines

<!--
Plot 1: 
Project timelines
Field 1: Start date
Field 2: End date
-->

```{r Date range inputs for project timelines plot}
#| content: card-sidebar

# These dateRangeInputs control the 
dateRangeInput(
  'projectStartRange',
  'Project start date range',
  start = min(projects$StartDate),
  end = max(projects$StartDate),
  min = min(projects$StartDate),
  max = max(projects$StartDate),
  format = "yyyy-mm-dd",
  startview = "month",
  weekstart = 0,
  language = "en",
  separator = " to "
)

dateRangeInput(
  'projectEndRange',
  'Project end date range',
  start = min(projects$EndDate),
  end = max(projects$EndDate),
  min = min(projects$EndDate),
  max = max(projects$EndDate),
  format = "yyyy-mm-dd",
  startview = "month",
  weekstart = 0,
  language = "en",
  separator = " to "
)

```

```{r Plot project timelines}
#| title: Project timelines

plotlyOutput("projectTimelines")
```

# Geographic spend

```{r Inputs for the geographic spend map}
#| content: card-sidebar

checkboxGroupInput(
  "countrySelect",
  "Countries",
  choices = c("UK", "Spain"),
  selected = "UK",
  inline = FALSE,
  width = '100%'
)

dateRangeInput(
  'projectEndRange',
  'Project end date range',
  start = min(projects$EndDate),
  end = max(projects$EndDate),
  min = min(projects$EndDate),
  max = max(projects$EndDate),
  format = "yyyy-mm-dd",
  startview = "month",
  weekstart = 0,
  language = "en",
  separator = " to "
)

```

```{r Total project spend mapped by customer city}
#| title: Total project budget by location


plotlyOutput("geoData")
```



```{r}
#| context: server

##################################################
# Timeline view
##################################################
timelineFilteredProjects <- reactive({
  projects %>%
    filter(StartDate >= input$projectStartRange[1]) %>%
    filter(StartDate <= input$projectStartRange[2]) %>%
    filter(EndDate >= input$projectEndRange[1]) %>%
    filter(EndDate <= input$projectEndRange[2])
})

timelineData <- reactive({
  data.frame(event = timelineFilteredProjects()$ProjectName,
             start = as.Date(timelineFilteredProjects()$StartDate), 
             end   = as.Date(timelineFilteredProjects()$EndDate),
             group = "Projects")
})

output$projectTimelines <- renderPlotly({
  vistime(
    timelineData(),
    optimize_y = FALSE
    )
})

##################################################
# Map view
##################################################

df.geo_budget_react <- reactive({
  df.geo_budget %>%
    filter(Country %in% input$countrySelect)
})

output$geoData <- renderPlotly({
  # Based on https://www.r-bloggers.com/2017/08/tidyverse-practice-mapping-large-european-cities/
  theme.maptheeme <-
  theme(text = element_text(family = "Gill Sans", color = "#444444")) +
  theme(panel.grid = element_blank()) +
  theme(axis.text = element_blank()) +
  theme(axis.ticks = element_blank()) +
  theme(axis.title = element_blank()) +
  theme(legend.background = element_blank()) +
  theme(legend.key = element_blank()) +
  theme(legend.title = element_text(size = 18)) +
  theme(legend.text = element_text(size = 10)) +
  theme(panel.background = element_rect(fill = "#596673")) +
  theme(panel.grid = element_blank())

p <- ggplot() +
  geom_polygon(
    data = map.europe,
    aes(x = long, y = lat, group = group, text = " "),
    fill = "#DEDEDE",
    colour = "#818181",
    linewidth = .15
  ) +
  geom_point(
    data = df.geo_budget_react(),
    aes(x = lon, y = lat, name = City, size = Budget),
    color = "red",
    alpha = .6
  ) +
  coord_cartesian(xlim = c(-30,50), ylim = c(32,70)) +
  theme.maptheeme
})
```
